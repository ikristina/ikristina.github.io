---
import '../../styles/global.css';
import Header from '../../components/Header.astro';
import Sidebar from '../../components/Sidebar.astro';

export async function getStaticPaths() {
  const allPosts = Object.values(await import.meta.glob('../blog/*.md', { eager: true }));
  const now = new Date();
  const publishedPosts = allPosts.filter(post => 
    new Date(post.frontmatter.date) <= now && !post.frontmatter.draft
  );
  const sortedPosts = publishedPosts.sort((a, b) => new Date(b.frontmatter.date) - new Date(a.frontmatter.date));
  
  const postsPerPage = 8;
  const totalPages = Math.ceil(sortedPosts.length / postsPerPage);
  
  return Array.from({ length: totalPages }, (_, i) => ({
    params: { page: String(i + 1) },
    props: { 
      posts: sortedPosts.slice(i * postsPerPage, (i + 1) * postsPerPage),
      currentPage: i + 1,
      totalPages,
      allPosts: sortedPosts
    }
  }));
}

const { posts, currentPage, totalPages, allPosts } = Astro.props;

// Generate calendar for current month
const today = new Date();
const currentMonth = today.getMonth();
const currentYear = today.getFullYear();
const firstDay = new Date(currentYear, currentMonth, 1);
const startDate = new Date(firstDay);
startDate.setDate(startDate.getDate() - firstDay.getDay());

const calendarDays = [];
for (let d = new Date(startDate); calendarDays.length < 42; d.setDate(d.getDate() + 1)) {
  const dateStr = d.toISOString().split('T')[0];
  const hasPost = allPosts.some(post => {
    if (!post.frontmatter.date) return false;
    const postDate = new Date(post.frontmatter.date);
    if (isNaN(postDate.getTime())) return false;
    return postDate.toISOString().split('T')[0] === dateStr;
  });
  const isToday = d.toDateString() === today.toDateString();
  const isCurrentMonth = d.getMonth() === currentMonth;
  calendarDays.push({ date: d.getDate(), hasPost, isToday, isCurrentMonth, fullDate: dateStr });
}

// Generate tag cloud from all posts
const tagCounts = {};
allPosts.forEach(post => {
  post.frontmatter.tags?.forEach(tag => {
    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
  });
});
const tags = Object.entries(tagCounts).map(([tag, count]) => ({ tag, count }));

const postDates = allPosts.map(p => p.frontmatter.date).filter(Boolean);
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/png" href="https://avatars.githubusercontent.com/u/10219431" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Blog - Page {currentPage}</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&family=Source+Serif+Pro:ital,wght@0,400;0,600;1,400&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">

	</head>
	<body>
		<Header />
		<div class="content-wrapper">
			<div class="main-content">
				<main>

				<ul>
					{posts.map((post) => (
						<li>
							<a href={post.url}>{post.frontmatter.title}</a>
							<p class="date">{post.frontmatter.date}</p>
							<p class="description">{post.frontmatter.description}</p>
							<div class="tags">
								{post.frontmatter.tags?.map((tag) => (
									<a href={`/tags/${tag}`} class="tag">{tag}</a>
								))}
							</div>
							<a href={post.url} class="read-more">Read more →</a>
						</li>
					))}
				</ul>
				
				{totalPages > 1 && (
					<nav class="pagination">
						{currentPage > 1 && (
							<a href={currentPage === 2 ? '/' : `/page/${currentPage - 1}`} class="page-link">← Previous</a>
						)}
						<span class="page-info">Page {currentPage} of {totalPages}</span>
						{currentPage < totalPages && (
							<a href={`/page/${currentPage + 1}`} class="page-link">Next →</a>
						)}
					</nav>
				)}
				
					<footer>
						<p>© 2025 Threads of Thought. Built with <a href="https://astro.build">Astro</a>.</p>
					</footer>
				</main>
			</div>
			<Sidebar posts={allPosts} />
		</div>
	</body>
</html>